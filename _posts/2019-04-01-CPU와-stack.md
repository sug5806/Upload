CPU :
* 데이터 버스 : 데이터가 이동하는 통로(양방향)
* 주소 버스 : 주소 이동하는 통로(단방향)
* CU : 실제로 명령을 실행하는 주체 (총감독)-> IR에 있는 명령어를 읽어 실행함
* PC(Program Counter) : 다음에 실행될 인스트력션(기계어)이 메모리(RAM)에서 저장된 곳의 주소값을 저장하는 레지스터
    * 기계어 : 어셈블리어(기계어를 1:1로 대응해서 사람이 읽을 수 있게 바꾼것)
* IR(Instrcution Register : 현재 실행 중인 인스터럭션 자체가 저장된 레지스터
    * 다음에 실행할 명령어를 가져오기 위해 제어 버스(Control Bus)에는 READ 모드를 전달하고, 주소 버스에는 다음에 실행할 명령어인 add ax, bx가 저장되어 있는 주소인 0x2를 전달합니다  주소 0x2번지에서 명령어 add ax, bx를 데이터 버스를 통해 IR로 전달합니다
* ALU = 사칙연산과 논리계산
    * 컨트롤 버스의 read라인을 통해 모드를 전달하고 메모리의 스택프레임 안에있는 변수의 주소를 통해 값을 읽고 데이터 버스를 통해 읽어와 AX로 저장한후 ALU로 계산을 하고 다시 AX에 저장을 한뒤에 메모리에 전달하여 저장함
* 범용레지스터 : 데이터를 일시적으로 저장
* 클럭 : 클럭에 맞춰 인스트럭션의 전달을 완료하거나 전달하고있는 과정

instruction cycle
* fetch : PC가 가리키고 있던 익스트럭션을 메모리에서 CPU의 IR로 가져오는 과정
    * MMU를 통해 PC에있는 메모리주소를 convert하고 MAR로 전달?
* decode : CU가 IR을 분석, 해석하는 과정
* execute : 연산을 하는것
* wirte back : 최종적으로 연산한것을 메모리에 저장하는 과정


하드웨어적) 한번에 보낼 수 있는 데이터의 양 ___ CPU와 메모리가 연결되어있는 와이어 갯수가 곧 bit (ex 64bit 컴퓨터는 와이어가 64개)
32bit --> 2진수 32승 64 bit --> 2진수 64승

주기 : 인스트럭션이 실행되거나 실행되고있는 시간
CPI (Clock cycles per instruction) : Load계열의 경우(CPU내부말고 외부를 거쳐야 하는 명령어)는 Instruction당 clock수가 3정도됨 add같은 명령어는 1임 Ex) 더 짧은데 실행시간은 더 길다 = Line당 CPI가 높다

로우레벨은 오로지 어셈블리어 하나 뿐 : 어셈블리어는 기계어로 1:1로 대응됨, 어셈블리어를 하려면 레지스터 이름까지 다 알아야함, CPU가 다르면 다시 프로그래밍 해야함, 하드웨어에 의존적임



---



ESP(Stack Pointer) : 스택프레임을 만들고 스택세그먼트의 맨위를 가리킨다
FP(Frame Pointer)  = BP(Base Pointer) : 스택 frame의 기준(가운데)을 가리킨다, 변수에 접근할때 기준점
EBP(extended base pointer) : 함수의 기준점을 가리키고있음 -> main의 기준점을 가리키고있다가 add함수를 호출하면 add함수 스택에 main함수의 기준점 주소를  add함수 스택에 쌓음
* EBP를 기준으로 +-를 하면 변수에 접근이 가능함
ESP -> ESP - 지역변수 갯수 만큼 -를 시켜 공간을 미리 확보함 : 스택은 주소공간에서 맨 아래부분(주소가 큰부분 :0xFFFFFFFF)부터 할당되므로 -를 해야 확장 개념임
* 미리 확보해놓는 이유 : 스택프레임이란 함수가 실행되면 함수의 지역변수를 미리 확보해야 하나 그렇지 않으면 스택 프레임이란 개념이 깨짐

함수내에서 다른 함수를 불러오기직전에 함수호출 다음의 주소(return address)를 스택에 쌓아둠
